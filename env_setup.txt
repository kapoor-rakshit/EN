
For SETUP refer "SetUpinstructions.docx"



NOTE :  AngularJS is for building CLIENT-side web applications
        NodeJs is used to build SERVER-side applications
        expressJs is a NodeJs framework to build websites / web services using principles and approaches of node.js.



EVENT Loop in NodeJs    (Refer Screenshot)



CALLBACKs
callbacks are used for async code execution.

PROMISEs
It is fair to say promises are just syntactic sugar.
Everything you can do with promises you can do with callbacks.
The deep reason why promises are often better is that they're more composeable, 
which roughly means that combining multiple promises "just works", while combining multiple callbacks often doesn't.
For instance, it's trivial to assign a promise to a variable and attach additional handlers to it later on,
or even attach a handler to a large group of promises that gets executed only after all the promises resolve.
While you can sort of emulate these things with callbacks, it takes a lot more code, is very hard to do correctly,
and the end result is usually far less maintainable.

OBSERVABLEs
Both Promises and Observables will help us work with the asynchronous functionalities in JavaScript.
They are very similar in many cases, however, there are still some differences between the two as well,
promises are values that will resolve in asynchronous ways like http calls. 
On the other hand, observables deal with a sequence of asynchronous events.

The main differences between them are listed below:
Promise
--------
 having one pipeline
 usually only use with async data return
 not easy to cancel

Observable
-----------
 are cancellable
 are retriable by nature such as retry and retryWhen
 stream data in multiple pipelines
 having array-like operations like map, filter, forEach.. etc
 can be created from other sources like events
 they are functions, which could be subscribed later on


Async / Await
REFERENCE : https://www.geeksforgeeks.org/using-async-await-in-node-js/
------------------------------------------------------------------------
With Node v8, the async/await feature was officially rolled out by the Node to deal with Promises and function chaining.
The functions need not to be chained one after another, simply await the function that returns the Promise.
But the function async needs to be declared before awaiting a function returning a Promise.

Example:
async function fun1(req, res){
  let response = await request.get('http://localhost:3000');
    if (response.err) { console.log('error');}
    else { console.log('fetched response');
}

The code above basically asks the javascript engine running the code to wait for the request.get() function to complete
before moving on to the next line to execute it.
The request.get() function returns a Promise for which user will await.
Code writing and understanding becomes easy with async/await.



MODULES
.. Builtin modules   (fs, http,   etc...)
.. Project modules   (user created)
.. Public  modules   (npm)

.. These are exported and used in another file
   var modulename = require('./module_to_be_exported')      // "require" is similar to import



EVENT EMITTER
.. Publisher emits EVENT and Subscriber subscribes for EVENT
.. Builtin EVENTEmitter
.. Project modules/User Created



STREAMS
Stream are instances of event emitter. These can be read, write, OR both
. For Small files read
.. "pipe" to other when read from another

. For Large files , read in chunks
.. "readable" and "end" are builtin for readstream

. For Syncronous file read ie untill not read the file it will not go to next line
.. This is referred as blocking code execution
.. fs (FileSystem)
.. fs.readFileSync            // readFileSyncronously
.. fs.statSync                // stats of file like size, .... etc..

.     Asyncronous file read : DEFAULT behaviour of node
.. fs.stat



PROCESS MODULE
.. process.pid
.. process.cwd()
.. process.version     .... etc ...



OS MODULE
.. os.hostname()
.. os.totalmem()
.. os.freemem()      ..... etc ....



HTTP SERVER
. Server request using NODE


. Server request using EXPRESS


.. Routing   (Refer Screenshots)
...  route files added under routes folder

.. Dynamic routing
...  using PARAMS    /:id
...  using QUERY     /?id=112&name=ra20024024                    // NOTE : use of ?

.. ENV CONFIG
...  variables inited during run for program to behave accordingly.
...  On windows : set CONFIG_VAR=development                        // set env variable , NOTE : no space , no "quotes" please :)
                  node filename.js                                  // run your file



.. HTML rendered VIEW

     INDEX.js  --->  routes/COMPONENT.js  --->  templates/VIEW.jade

...  Using JADE template VIEW engine (now known as PUG)  ,  install using   "npm install jade"
...  define 'view engine' , 'views'    etc...
...  .jade file uses indentation and use   '|'   for breaking code into mulltiple lines
...   pass data from .js to .jade using  #{var}  in  .jade   and   .render("", {var : value}) in routes/.js


.. BODY-PARSER  for  working with FORM data
...  "npm install body-parser"
...  set 'views' , 'view engine'
...  use 'bodyParser.json()' , 'bodyParser.urlencoded({extended : false})'
...  'router.post'  for  submitting form data    NOTE : This address must be same as form action attribute value as specified in .jade


.. STYLING
...  use 'express.static()'




.. COOKIES and SESSIONS
...  cookies are identifiers to tell server that request is coming from a client that is earlier encountered too.
     This is important as http is stateless protocol.  It is stored at CLIENT side.

...  sessions are duration of activity tracked by server. stored at SERVER side.

...  "npm install cookie-parser"
     "npm install express-session"

...  check status on storage tab of BROWSERs INSPECTOR window.




.. APP.LOCALS
.. // This provides value to variables in all .jade files coz inited in index.js with app.locals

...  app.locals.VARNAME = {var1 : val1 , var2 : val2}
...  app.locals.VARNAME = "VALUE"



.. ERROR HANDLING
...  If error not handled in code , ERROR will be prompted at CLIENT side.
...  define functions for handling error  and  make   app.use(funcname);

 
